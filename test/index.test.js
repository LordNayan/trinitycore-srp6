import * as crypto from 'crypto';
import { computeVerifier, params, generateECCKeyPair, signMessage, verifySignature } from '../index.js';
import { expect } from 'chai';

// Initialize buf here, outside of the describe blocks.
const buf = crypto.randomBytes(32);

const janeDoeAccount = {
    username: `janedoe`,
    password: `j@n3d0e`,
    salt: `25F5729D0D03D18F1528AF29F7CC83257081D8C4CA1772817C5CD36605BFB12F`,
    verifier: `80DB6CDF821CE6A8AA8E6E45AC958A8E38C3E13E0F0256BB57E63D71AC631851`,
};

describe('Test computeVerifier', function() {
    [`trinitycore`, `azerothcore`].forEach((serverType) => {
        it(`Test verifier for ${serverType}`, () => {
            const verifier = computeVerifier(params[serverType], buf, `tic`, `tac`);
            expect(verifier).to.be.instanceOf(Buffer);
        });

        it(`Test raise identifier length error for ${serverType}`, () => {
            expect(() => computeVerifier(params[serverType], buf, `a`.repeat(17), `tac`))
                .to.throw(RangeError, 'The identity should have maximum 16 characters');
        });

        it(`Test raise password length error for ${serverType}`, () => {
            expect(() => computeVerifier(params[serverType], buf, `tic`, `a`.repeat(17)))
                .to.throw(RangeError, 'The password should have maximum 16 characters');
        });

        it(`Test verifier generated by C++ account creation for ${serverType}`, () => {
            const salt = Buffer.from(janeDoeAccount.salt, 'hex');
            const verifier = computeVerifier(
                params[serverType],
                salt,
                janeDoeAccount.username,
                janeDoeAccount.password
            );
            const strVerifier = verifier.toString('hex').toUpperCase();
            expect(janeDoeAccount.verifier).to.equal(strVerifier);
        });
    });
});

describe('Test custom params', function() {
    it('Test verifier with custom params', () => {
        const salt = Buffer.from(janeDoeAccount.salt, 'hex');
        const myParam = {
            N_length_bits: 256,
            N: BigInt('0x8A4B645E89E1535BBDAD5B8B290650530801B18EBFBF5E8FAB3C82872A3E9BB7'),
            g: BigInt('0x7'),
            hash: 'sha1'
        };

        const myVerifier = computeVerifier(
            myParam,
            salt,
            janeDoeAccount.username,
            janeDoeAccount.password
        );
        const strVerifier = myVerifier.toString('hex').toUpperCase();

        expect('B1EBEABC2AEE9284E6B48E300BB4D47D05A952A248C2B37DB1DF6143568DB449').to.equal(strVerifier);
    });
});

describe('Test ECC Functionality', function() {
    it('should generate an ECC key pair', async () => {
        const { publicKey, privateKey } = await generateECCKeyPair();
        expect(publicKey).to.be.instanceOf(crypto.KeyObject);
        expect(privateKey).to.be.instanceOf(crypto.KeyObject);
    });

    it('should sign and verify a message', async () => {
        const { publicKey, privateKey } = await generateECCKeyPair();
        const message = 'Hello, ECC!';
        const signature = signMessage(privateKey, message);

        const isValid = verifySignature(publicKey, message, signature);
        expect(isValid).to.be.true;
    });

    it('should invalidate a wrong signature', async () => {
        const { publicKey, privateKey } = await generateECCKeyPair();
        const message = 'Hello, ECC!';
        const wrongSignature = Buffer.from('00'.repeat(64), 'hex'); // deliberately wrong signature

        const isValid = verifySignature(publicKey, message, wrongSignature);
        expect(isValid).to.be.false;
    });

    it('should perform efficiently with large inputs', () => {
        const largeIdentity = 'a'.repeat(16);
        const largePassword = 'b'.repeat(16);
        const largeSalt = crypto.randomBytes(32);
      
        // Measure execution time
        const start = process.hrtime();
        computeVerifier(params['trinitycore'], largeSalt, largeIdentity, largePassword);
        const end = process.hrtime(start);
        console.log(`Performance test took ${end[1] / 1e6} ms`);
      });

      it('should perform end-to-end with verifier and ECC', async () => {
        const { publicKey, privateKey } = await generateECCKeyPair();
        const message = 'Test Message';
        const signature = signMessage(privateKey, message);
      
        const salt = crypto.randomBytes(16);
        const verifier = computeVerifier(params['trinitycore'], salt, 'user', 'pass');
        const isValid = verifySignature(publicKey, message, signature);
      
        expect(isValid).to.be.true;
        // Additional checks can be added here
      });
      
});
